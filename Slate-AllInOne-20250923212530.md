# Slate Snapshot — 2025-09-23 21:25:30 (All-in-one)

Scope
- This snapshot consolidates everything requested into one document:
  A) Exact route inventory (grounded in src/main.rs)
  B) Screen-to-handler/template mapping with request/response shapes
  C) Deeper parseltongue-style call-chain summaries for key components
  D) A CI-ready “PR Impact Gate” script you can drop into the repo to quantify change risk
- It also reiterates the user journey and where parseltongue benefits us most.

A) Route inventory (from src/main.rs)
Pages & assets
- GET  / → handlers::pages::serve_root_page (demo-aware; serves demo or chat)
- GET  /chat → assets::serve_chat_interface
- GET  /login → handlers::pages::serve_login_page (demo-aware)
- GET  /demo → assets::serve_demo_page
- GET  /manifest.json → assets::serve_manifest
- GET  /static/*path → assets::serve_static_asset

Demo API
- GET  /api/demo/status → handlers::pages::demo_status
- POST /api/demo/initialize → handlers::pages::initialize_demo

Health & metrics
- GET  /health → health::health_check
- GET  /health/ready → health::readiness_check
- GET  /health/live → health::liveness_check
- GET  <metrics endpoint> → metrics::metrics_endpoint (if enabled)
- GET  /metrics/summary → metrics::metrics_summary (if enabled)

WebSocket
- GET  /ws → handlers::websocket::websocket_handler (if websockets enabled)

Core API
- POST /api/auth/login → handlers::auth::login
- POST /api/auth/logout → handlers::auth::logout
- GET  /api/users/me → handlers::users::get_current_user
- GET  /api/rooms → handlers::rooms::get_rooms
- POST /api/rooms → handlers::rooms::create_room
- GET  /api/rooms/:id → handlers::rooms::get_room
- POST /api/rooms/:id/members → handlers::rooms::add_room_member
- GET  /api/rooms/:id/messages → handlers::messages::get_messages
- POST /api/rooms/:id/messages → handlers::messages::create_message

Feature APIs
- Search (if enabled): GET /api/search → handlers::search::search_messages
- Sounds (if enabled): 
  - GET /api/sounds → handlers::sounds::list_sounds
  - GET /api/sounds/:sound_name → handlers::sounds::get_sound
  - GET /api/sounds/:sound_name/info → handlers::sounds::get_sound_info
- Push (if enabled):
  - POST /api/push/subscriptions → handlers::push::create_push_subscription
  - DELETE /api/push/subscriptions/:id → handlers::push::delete_push_subscription
  - GET /api/push/preferences → handlers::push::get_notification_preferences
  - PUT /api/push/preferences → handlers::push::update_notification_preferences
  - GET /api/push/vapid-key → handlers::push::get_vapid_public_key
  - POST /api/push/test → handlers::push::send_test_notification (debug only)
- Bot (if enabled):
  - GET/POST /api/bots → handlers::bot::list_bots / create_bot
  - GET/PUT/DELETE /api/bots/:id → handlers::bot::get_bot / update_bot / delete_bot
  - POST /rooms/:room_id/bot/:bot_key/messages → handlers::bot::create_bot_message

B) Screen-to-handler/template mapping with request/response shapes
1) Root and Login (demo-aware)
- GET / (pages.rs):
  - If demo data present (admin@campfire.demo exists): serve demo landing (assets::serve_demo_page)
  - Else: serve chat interface (assets::serve_chat_interface)
- GET /login (pages.rs):
  - Templates: templates/login_demo.html or templates/login.html (selected by demo mode)
- POST /api/auth/login (auth.rs)
  - Request (JSON): { "email": string, "password": string }
  - Response (200): { "user": User, "session_token": string } and Set-Cookie: session_token=...; HttpOnly; SameSite=Lax; Max-Age=2592000
- POST /api/auth/logout (auth.rs)
  - Response (200): { "message": "Logged out successfully", "success": true } and clears session cookie

2) Rooms (index, details, membership)
- GET /api/rooms (rooms.rs)
  - Response (200): Room[]
- POST /api/rooms (rooms.rs)
  - Request (JSON): { "name": string, "topic"?: string, "room_type": "Open"|"Closed"|"Direct" }
  - Response (201): Room
- GET /api/rooms/:id (rooms.rs)
  - Response: 200 Room | 403 access denied | 404 not found | 400 invalid UUID
- POST /api/rooms/:id/members (rooms.rs)
  - Request (JSON): { "user_id": uuid, "involvement_level": "Member"|"Admin" }
  - Response (201) on success (admin-only); robust error mapping on invalid/duplicate

3) Messages (timeline + compose)
- GET /api/rooms/:id/messages (messages.rs)
  - Query: limit<=100, before?=MessageId
  - Response (200): { "messages": Message[], "has_more": bool }
- POST /api/rooms/:id/messages (messages.rs)
  - Request (JSON): { "content": string(1..10000), "client_message_id": uuid }
  - Response (201): { "message": Message }
  - Errors: 400 invalid content/ids, 403 unauthorized for room, 429 rate limit, 500 server errors
- Deduplication: client_message_id prevents duplicate insertions on retries

4) WebSocket (live chat, presence, typing)
- GET /ws (websocket.rs) auth via:
  - Query: ?token=<session_token> OR Authorization: Bearer <token> OR Cookie: session_token=<token>
- Incoming message variants (JSON):
  - CreateMessage { room_id, content, client_message_id }
  - UpdateLastSeen { message_id }
  - JoinRoom { room_id }
  - LeaveRoom { room_id }
  - StartTyping { room_id }
  - StopTyping { room_id }
- Outgoing message variants (JSON):
  - Error { message, code }
  - Pong { data }
- Effects:
  - Join/Leave → presence broadcast + presence update
  - Start/Stop typing → typing broadcasts
  - CreateMessage → message creation path + broadcast to room

5) Search (feature)
- GET /api/search (search.rs)
  - Query: q, limit, offset?, room_id?
  - Response (200): SearchResponse (service-defined)
  - Errors: structured JSON with StatusCode derived from SearchError

6) Sounds, Push, Bot (features)
- Sounds: discovery and metadata to support /play in chat
- Push: VAPID-key exposure, subscription CRUD, preferences
- Bot: Bot CRUD + per-room bot message endpoint

C) Deeper parseltongue-style call-chain summaries (key components)
Note: Derived from code structure and measured impact where available.

1) MessageService::create_message_with_deduplication (hot path)
- Callers:
  - HTTP: handlers::messages::create_message
  - WS: handlers::websocket::handle_incoming_message (Incoming::CreateMessage)
- Flow:
  - Validate user membership for room
  - Sanitize and validate content; enforce length (<=10000)
  - Insert message with UNIQUE(client_message_id, room_id) → return existing on conflict
  - Update room.last_message_at
  - Broadcast to room via ConnectionManager (presence-aware)
  - Optionally trigger push notifications (mentions/DMs) if configured
- Measured: ~17 callers observed in current snapshot (entry-point hub)

2) AuthService
- authenticate(email, password)
  - Used by handlers::auth::login; on success returns session token (also returned in body)
- validate_session(token)
  - Used by auth flow and WebSocket upgrade to authorize users
- logout/revoke_session(token)
  - Used by handlers::auth::logout (always 200; clears cookie regardless of backend revocation result)

3) RoomService
- create_room(name, topic?, room_type, creator_id)
  - Called by handlers::rooms::create_room; sets creator as admin
- add_member(room_id, user_id, actor_id, involvement_level)
  - Called by handlers::rooms::add_room_member; enforces permissions
- check_room_access(room_id, user_id)
  - Used by get_room + WS JoinRoom verification

4) SearchService::search_messages
- Called by handlers::search::search_messages after sanitization/validation
- Returns FTS5-backed matches across accessible rooms

5) ConnectionManagerImpl
- add_connection/remove_connection(user_id, connection_id, tx)
- broadcast_to_room(room_id, WebSocketMessage)
- broadcast_presence_update(room_id)
- start_typing/stop_typing(user_id, room_id)
- update_last_seen_message(connection_id, message_id)
- Used primarily by WebSocket handler and MessageService broadcasting

D) CI-ready “PR Impact Gate” script (parseltongue-assisted)
- Purpose: quantify change risk and attach actionable context to PRs automatically.
- Behavior:
  - Detect touched entities (types/functions) with simple heuristics (ripgrep)
  - Run parseltongue queries for uses/calls/context when available
  - Print a summary and flag risk when thresholds are exceeded

Example script (scripts/pr-impact.sh):
```bash
#!/usr/bin/env bash
set -euo pipefail

# Requirements: ripgrep (rg); optional: ./parseltongue in ./parseltongue_workspace

# 1) Gather touched Rust symbols naively from diffs or working tree
# Fallback: scan src/ for common service/handler symbols
SYMBOLS=()
SYMBOLS+=(AuthService RoomService MessageService SearchService ConnectionManagerImpl)
SYMBOLS+=(create_message_with_deduplication authenticate validate_session create_room add_member get_room_messages)

echo "== PR Impact Gate =="
echo "Symbols to probe: ${SYMBOLS[*]}"

PT="./parseltongue_workspace/parseltongue"
HAVE_PT="no"
if [[ -x "$PT" ]]; then
  HAVE_PT="yes"
fi

risk=0
for s in "${SYMBOLS[@]}"; do
  uses="-"
  calls="-"
  if [[ "$HAVE_PT" == "yes" ]]; then
    uses=$("$PT" query uses "$s" | wc -l || echo "0")
    # For functions only; harmless on types (might print 0)
    calls=$("$PT" query calls "$s" | wc -l || echo "0")
  else
    # Fallback: rough counts via grep
    uses=$(rg -n "$s" src | wc -l || echo "0")
    calls="$uses"
  fi
  printf "%-34s uses=%-6s calls=%-6s\n" "$s" "$uses" "$calls"

  # Simple risk thresholds
  if [[ "$uses" =~ ^[0-9]+$ && "$uses" -ge 10 ]]; then
    risk=$((risk+1))
  fi
  if [[ "$calls" =~ ^[0-9]+$ && "$calls" -ge 10 ]]; then
    risk=$((risk+1))
  fi

  # Optional: one-liner context (human)
  if [[ "$HAVE_PT" == "yes" ]]; then
    "$PT" generate-context "$s" --format human | sed -n '1,15p' || true
    echo "----"
  fi
done

echo "Risk flags: $risk (>=2 suggests broader review and added tests)"
exit 0
```

How to use
- Commit the script at scripts/pr-impact.sh, make it executable, and wire it in CI or as a pre-push hook.
- If parseltongue isn’t available, it gracefully falls back to grep counts.

User journey (concise, mapped)
- Regular:
  1) GET /login → POST /api/auth/login (cookie set)
  2) Sidebar via GET /api/rooms → select/create room (POST /api/rooms)
  3) Room view: GET /api/rooms/:id + GET /api/rooms/:id/messages
  4) Live chat: GET /ws; compose via POST /api/rooms/:id/messages
  5) Optional: GET /api/search; push setup if configured
- Demo:
  1) GET / (demo landing) and GET /login (demo template)
  2) Optional POST /api/demo/initialize to seed users/rooms
  3) Explore pre-seeded rooms with live WS and search

Parseltongue value recap (short)
- Benefits: fast orientation, quantified impact, reusable workflows (impact, debugging, docs)
- Limits: name-sensitive queries; limited macro/generics expansion
- Verdict: integrates well here; worth using for pre-PR checks, debugging, and docs

Artifacts to open
- HTML graph: parseltongue_workspace/analysis_20250923193618/architecture.html
- Context packs: parseltongue_workspace/analysis_20250923193618/context_*.{txt,json}

Appendix: Rename plan (for existing snapshots)
- We’ll rename earlier SlateYYYY... files to Slate-Keyword-YYYY....md with keywords:
  - Initial, Overview, Routes, Executive, Impact, Assessment, Hotspots, Journey, Signals
- This all-in-one file will be renamed to Slate-AllInOne-20250923212530.md.
---

Toolkit usage (parseltongue-powered)
- Workspace: ./parseltongue_workspace (latest analysis symlinked as ./parseltongue_workspace/latest)
- Binary: place parseltongue at ./parseltongue or ./parseltongue_workspace/parseltongue

Core commands
- Ingest and generate viz + contexts:
  - scripts/pt ingest
  - scripts/pt ingest --extra "AppState,AuthService"   # add more contexts on ingest
- Open the latest architecture graph:
  - scripts/pt open              # prints path
  - scripts/pt open --open       # tries to open in browser (xdg-open)
- Quick repo orientation:
  - scripts/pt overview
  - scripts/pt routes --format table
- Token-efficient queries:
  - scripts/pt query uses MessageService
  - scripts/pt query calls create_message_with_deduplication
  - scripts/pt query grep MessageService
- Context snapshots:
  - scripts/pt context MessageService                 # human
  - scripts/pt context MessageService --json --out    # writes JSON to latest analysis dir
- Impact snapshot (risk pre-check):
  - scripts/pt impact
  - scripts/pt impact --entities "MessageService,RoomService" --functions "create_message_with_deduplication"

Notes
- Prior analysis outside parseltongue_workspace is preserved. New outputs are written under parseltongue_workspace/analysis_TIMESTAMP and linked via parseltongue_workspace/latest.
- Use these outputs in PRs to cut LLM tokens: paste counts, a few lines of human context, and a link to the viz, instead of raw code.

