# Slate Snapshot — 2025-09-23 19:22:02

Purpose
- Park current understanding of Campfire-on-Rust vs Original Campfire and outline next steps to analyze the codebase using parseltongue (Signature Interface Graph).

Summary: Original Campfire vs Campfire-on-Rust (User Journeys)
- Core parity: multi-room chat, DMs, @mentions, search, notifications, bots/API.
- Attachments: Rails original supports uploads + previews; Rust defers this (UI shows “coming soon”).
- First-run:
  - Rails: conventional deploy → admin/user creation → login → create first room (no explicit demo).
  - Rust: two specs exist — earlier “Demo mode with seeded data” vs DHH-inspired “First-Run Admin” (no demo, create admin on empty DB).
  - Recommendation: adopt First-Run Admin for both offline/server, keep demo mode out of MVP to simplify deployment and reduce complexity.
- Deployment:
  - Rails: Docker image includes web app + background + cache + SSL; persistent /rails/storage.
  - Rust: Single binary + Docker/Compose; persistent /app/data, /logs, /backups; health/metrics endpoints; VAPID push optional (enable in prod).
  - Offline-first is strong on Rust: run the binary, create admin, create first room, chat (push optional).
- Real-time + messaging:
  - Rust enforces client_message_id-based deduplication to prevent duplicates.
  - WebSocket parity (ActionCable-like), with recommended tests for reconnection/presence.
- Search:
  - Rust uses SQLite FTS5 for message search (journey equivalent to Rails).
- Notifications:
  - Rust supports Web Push (VAPID); likely disabled by default until configured in prod.

Key Docs/Artifacts Reviewed (high value)
- tests/USER_JOURNEY_TEST_SUMMARY.md and tests/user_journey_tests.rs (UAT journeys for onboarding, chat, deduplication, search, health, permissions, sounds/rich text, bots).
- .kiro/specs/campfire-rust-rewrite/requirements.md and design.md (MVP scope, anti-coordination mandates, First-Run setup, demo mode vs DHH alternative, technical contracts).
- .kiro/specs/dhh-simple-deployment/requirements.md (Radical simplicity: remove demo mode, zero-setup local, single binary works everywhere).
- docs/deployment-guide.md and DEPLOYMENT.md (Docker/Compose, reverse proxy, health/metrics).

Simple Calls to Ship (recommended)
- First-run: Implement First-Run Admin setup when DB is empty (no demo mode).
- Offline defaults: SQLite at ./data/campfire.db created automatically; push disabled until configured.
- API status codes: Keep 201 Created for resource creation; update tests expecting 200 to expect 201.
- Attachments: Maintain “Coming soon” UI; return 501 Not Implemented or hide endpoints.
- WebSocket tests: Add reconnection and presence tests to harden real-time journeys pre-release.

Next Steps: Use parseltongue (Signature Interface Graph)
Objective
- Rapidly understand the Rust codebase’s module/service boundaries, public interfaces, and call graph using parseltongue_workspace/parseltongue.

Planned Workflow
1) Study parseltongue docs (parseltongue_workspace/*.md) to confirm invocation, flags, and output formats.
2) Run parseltongue from repo root or the recommended working dir to generate:
   - Interface signature graph (services, handlers, models, middleware).
   - Cross-module dependency and public API surface.
   - Output artifacts (SVG/JSON/markdown) for quick browsing.
3) Target subsystems first:
   - Services: AuthService, RoomService, MessageService, SearchService, PushNotificationService, BotService, ConnectionManager.
   - Handlers: auth, users, rooms, messages, search, sounds, push, bot.
   - Database layer: schema creation, writer/transactions, FTS5 triggers.
4) Produce a short architecture note with:
   - Top-level components and their interfaces.
   - Edges (who calls whom), notable singletons/state managers.
   - Mapped to UATs to ensure coverage and surface gaps.

Open Questions (to resolve while using parseltongue)
- Exact CLI usage for parseltongue: working directory, include/exclude patterns, language modes.
- Best output format(s) for quick iteration (e.g., Graphviz/Mermaid/JSON).
- Whether to scope graph to src/ first, then expand to tests/ and templates/ as needed.

References (paths)
- Workspace: parseltongue_workspace/
  - PARSELTONGUE_BEST_PRACTICES_GUIDE.md
  - LIMITATIONS_AND_ADVANCED_TECHNIQUES.md
  - workflow_patterns.md
  - workflow_templates.md / WORKFLOW_TEMPLATES.md
  - rust_complexity_quick_reference.md
  - parseltongue (executable)
- Rust code areas to analyze:
  - src/handlers/* (auth, users, rooms, messages, search, sounds, push, bot)
  - src/services/* (AuthService, RoomService, MessageService, SearchService, PushNotificationServiceImpl, BotServiceImpl, ConnectionManagerImpl)
  - src/models/*, src/database/*, src/middleware/*, src/lib.rs, src/main.rs

Next Action
- Parse the parseltongue docs and invoke the tool to produce a Signature Interface Graph of src/, then summarize findings in a follow-up note and align them with UAT coverage.