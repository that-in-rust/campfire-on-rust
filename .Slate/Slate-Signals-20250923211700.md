# Slate Snapshot — 2025-09-23 21:17:00

Scope
- Creative, parseltongue-powered snapshot answering: “Will it benefit us, how, and where?”
- Includes a crisp assessment, concrete impact signals, the user journey, and actionable next steps.

Parseltongue — assessment and value
- What it is to us
  - A fast Signature Interface Graph engine with queries that surface relationships (who-uses-what, who-calls-what), plus an instant HTML architecture view and compact “context packs” for entities.
- Where it helps (high leverage here)
  - Refactors/PRs: Precise impact scope before edits (uses/calls counts) → better risk calls, fewer regressions.
  - Debugging: Quick caller chains and type users → faster root-cause isolation.
  - Onboarding/Docs: Architecture.html + generate-context snapshots → 10–15 minute ramp to 70–80% mental model.
- Limitations to keep in mind
  - Exact names matter (use debug --graph + grep for discovery).
  - Generics/macros aren’t fully expanded; prefer concrete implementors/usages.
  - Some queries (cycles) need specific targets; uses/calls + context usually suffice.
- Bottom line
  - Yes, it benefits us. The time-to-signal is excellent on this codebase. Worth integrating into daily flow (pre-PR check, debugging, doc refresh).

Measured impact signals (from current snapshot)
- Uses by component (higher = more central/riskier to change)
  - AppState: 11
  - AuthService: 5
  - RoomService: 4
  - MessageService: 4
  - SearchService: 4
  - PushNotificationServiceImpl: 4
  - BotServiceImpl: 5
  - ConnectionManagerImpl: 4
- Callers (entry-point heat)
  - create_message_with_deduplication: 17

How to read this
- Many “uses” → broad dependency surface: raise test coverage and review depth for changes.
- Many “callers” → contract hub: prefer additive changes or adapters; avoid breaking signatures.

Architecture at a glance (grounded in routes and handlers)
- Axum single-binary app with feature flags for websockets, search, sounds, push, bot.
- Pages & assets: /, /chat, /login, /demo, /manifest.json, /static/*
- Demo endpoints: /api/demo/status, /api/demo/initialize (seeded users/rooms if enabled)
- Core API: 
  - Auth: POST /api/auth/login, /api/auth/logout; users: GET /api/users/me
  - Rooms: GET/POST /api/rooms, GET /api/rooms/:id, POST /api/rooms/:id/members
  - Messages: GET/POST /api/rooms/:id/messages (201 on post; dedup on client_message_id)
  - WebSocket: GET /ws (query/header/cookie token auth) with Join/Leave/Typing/UpdateLastSeen/CreateMessage
- Feature APIs: search (/api/search), sounds (/api/sounds…), push (/api/push…), bot (/api/bots…)
- Health/metrics: /health, /health/ready, /health/live, /metrics (opt), /metrics/summary (opt)

User journey (screen-by-screen)
- Mode awareness
  - GET / and GET /login are demo-aware (presence of admin@campfire.demo switches templates/flows)
- Login
  - GET /login → render (demo or regular); POST /api/auth/login → 200 + session cookie; logout clears cookie
- Rooms home
  - GET /api/rooms populates sidebar; POST /api/rooms → 201 create (Open/Closed/Direct); GET /api/rooms/:id checks access
- Room chat
  - GET /api/rooms/:id/messages (history with has_more); POST /api/rooms/:id/messages → 201; dedup via client_message_id
  - GET /ws upgrades; handles CreateMessage, Join/Leave, Typing start/stop, UpdateLastSeen; broadcasts to room
- Direct messages
  - Use room_type=Direct; same underlying room/message paths
- Search (feature)
  - GET /api/search → FTS5-backed results across accessible rooms
- Push & sounds (feature)
  - Push: subscriptions/preferences and VAPID key; Sounds: list/metadata for /play commands

Artifacts you can open
- HTML architecture graph: parseltongue_workspace/analysis_20250923193618/architecture.html
- Context packs (human + JSON): parseltongue_workspace/analysis_20250923193618/context_*.{txt,json}

What I would do next with parseltongue (automation-ready)
- Pre-PR “impact gate”:
  - For edited entities, automatically output query uses <Type> and query calls <Function> + generate-context <Entity>.
  - If uses > 10 or callers > 10, require expanded tests/review.
- Debugging recipe cards:
  - Auth/session: calls authenticate, calls validate_session; context packs for AuthService + middleware.
  - Message duplication: calls create_message_with_deduplication; users WebSocketMessage; follow in architecture.html.
  - WS reconnect/presence: callers of update_last_seen_message; uses ConnectionManagerImpl.
- Docs refresh
  - Regenerate architecture.html on main merges; commit side-by-side with CHANGELOG.

Notes
- Prefer 201 Created for create endpoints (rooms, messages, members).
- Keep WS auth flexible (query/header/cookie) for client simplicity.
- Demo mode remains configurable; can be disabled without code churn.