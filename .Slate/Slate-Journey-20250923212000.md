# Slate Snapshot — 2025-09-23 21:20:00

Executive summary
- This snapshot uses parseltongue outputs to highlight change risk, hot paths, and a pragmatic user journey.
- Parseltongue is valuable here: it’s fast to run, gives clear impact counts, and yields an interactive architecture view for onboarding and reviews.

Parseltongue assessment (how it benefits us)
- Strengths
  - Near-instant orientation via architecture.html and generate-context for key services.
  - Risk clarity before edits using “uses” and “calls” to quantify blast radius.
  - Repeatable workflows (impact analysis, debugging traces, docs refresh) that we can automate later.
- Limits
  - Entity-name sensitivity: use debug --graph | grep to discover exact names first.
  - Macro/generic expansion is limited: favor concrete implementors and usage sites.
  - Some queries need specific targets; for broad scans, prefer generate-context + uses/calls.
- Bottom line
  - For this codebase, parseltongue gives high signal with low overhead. It’s worth integrating into refactor/PR workflows and docs.

Impact radar (measured)
- Uses by component (higher = more central)
  - AppState: 11
  - AuthService: 5
  - RoomService: 4
  - MessageService: 4
  - SearchService: 4
  - PushNotificationServiceImpl: 4
  - BotServiceImpl: 5
  - ConnectionManagerImpl: 4
- Callers for key function
  - create_message_with_deduplication: 17
- Reading the radar
  - Many “uses” → broader regression risk; add tests and review accordingly.
  - Many “callers” → treat as a hub; keep contracts stable and consider adapters when changing.

Hotspots to guard (UAT focus)
- Message pipeline (HTTP + WS)
  - Idempotent creation via client_message_id; content bounds; rate limits; auth/membership; broadcast to WS.
- Session lifecycle and auth
  - Login (cookie set), validate_session across APIs and WS, logout (cookie clear).
- Room access and membership
  - Create room (201), add_member (201), GET room details (403/404 on access).
- WebSocket presence and typing
  - Join/Leave → presence broadcast + presence refresh; Start/Stop typing; UpdateLastSeen for reconnects.

Screen-by-screen user journey (mapped to handlers/routes)
- Mode detection (demo-aware)
  - GET / and GET /login choose demo or regular templates based on seeded demo user (admin@campfire.demo).
- Login
  - GET /login (pages) → shows login (demo or regular)
  - POST /api/auth/login (auth) → 200, sets session cookie; POST /api/auth/logout → 200 clears
- Rooms
  - GET /api/rooms (rooms) → sidebar/dashboard list
  - POST /api/rooms (rooms) → 201 create (Open/Closed/Direct)
  - GET /api/rooms/:id (rooms) → access gate + metadata
- Room chat
  - GET /api/rooms/:id/messages (messages) → {messages, has_more}
  - POST /api/rooms/:id/messages (messages) → 201; dedup on client_message_id
  - GET /ws (websocket) → auth via query/header/cookie; supports CreateMessage, Join/Leave, Typing start/stop, UpdateLastSeen; broadcasts for presence and messages
- Direct messages
  - Room creation with room_type=Direct; then same flows as rooms
- Search (feature-flagged)
  - GET /api/search (search) → FTS5-backed results across accessible rooms
- Sounds (feature-flagged)
  - GET /api/sounds, /api/sounds/:name, /api/sounds/:name/info (sounds)
- Push (feature-flagged)
  - GET /api/push/vapid-key, POST/DELETE /api/push/subscriptions, GET/PUT /api/push/preferences
- Demo flows
  - GET /api/demo/status, POST /api/demo/initialize; demo landing via GET /demo or root when demo is on

Where to view artifacts
- Architecture visualization: parseltongue_workspace/analysis_20250923193618/architecture.html
- Component contexts (human + JSON): parseltongue_workspace/analysis_20250923193618/context_*.{txt,json}

What I’d automate next with parseltongue
- PR impact gate:
  - For changed entities, print: query uses <Type>, query calls <Function>, and generate-context <Entity>.
  - Thresholds to flag: uses > 10 or callers > 10.
- Architecture refresh on merge:
  - Regenerate architecture.html and include in release notes.
- Debugging cards:
  - Store ready-made query sets for auth/session, message duplication, and WS reconnect issues.

Notes
- Prefer 201 Created on create endpoints (rooms/messages/members).
- Keep WS auth flexible (token in query/header/cookie) to simplify clients.
- Demo mode is configurable; leave as feature-flagged without code churn.